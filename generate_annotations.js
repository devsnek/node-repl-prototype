'use strict';

const fs = require('fs');
const ts = require('typescript');
const Module = require('module');

const HasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);
const needToRequire = new Set();
const needToIgnore = new Set(['repl', 'domain']);

const program = ts.createProgram([
  require.resolve('typescript/lib/lib.esnext.d.ts'),
], { noLib: true });

const annotationMap = new Map();

function arrayEqual(a1, a2) {
  if (a1.length !== a2.length) {
    return false;
  }
  for (let i = 0; i < a1.length; i += 1) {
    if (a1[i] !== a2[i]) {
      return false;
    }
  }
  return true;
}

function parseTSFunction(receiver, func) {
  let namespace;
  let key = receiver;
  if (/Constructor$/.test(receiver)) {
    namespace = global[receiver.replace(/Constructor$/, '')];
    key = namespace.name;
  } else if (HasOwnProperty(global, receiver)) {
    namespace = global[receiver];
    if (namespace && namespace.prototype) {
      namespace = namespace.prototype;
      key = `${receiver}.prototype`;
    }
  } else if (!needToIgnore.has(receiver) && Module.builtinModules.includes(receiver)) {
    needToRequire.add(receiver);
    namespace = require(receiver);
  }

  if (!namespace) {
    return;
  }

  const name = func.name.text || func.name.escapedText;
  const method = namespace[name];
  if (!method) {
    return;
  }

  key = `${key}.${name}`;

  const args = func.parameters
    .map((p) => {
      let text = p.name.escapedText;
      if (p.questionToken) {
        text = `?${text}`;
      }
      if (p.dotDotDotToken) {
        text = `...${text}`;
      }
      return text;
    })
    .filter((x) => x !== 'this');

  let entry = annotationMap.get(key);
  if (!entry) {
    entry = [];
    annotationMap.set(key, entry);
  }

  // ignore duplicates
  if (entry.some((a) => arrayEqual(a, args))) {
    return;
  }

  entry.push(args);
}

program.getSourceFiles().forEach((file) => {
  ts.forEachChild(file, (node) => {
    if (node.kind === ts.SyntaxKind.InterfaceDeclaration) {
      for (const member of node.members) {
        if (member.kind === ts.SyntaxKind.MethodSignature) {
          parseTSFunction(node.name.text || node.name.escapedText, member);
        }
      }
    } else if (node.kind === ts.SyntaxKind.FunctionDeclaration) {
      parseTSFunction('global', node);
    } else if (node.kind === ts.SyntaxKind.ModuleDeclaration) {
      const receiver = node.name.escapedText || node.name.text;
      for (const statement of node.body.statements) {
        if (statement.kind === ts.SyntaxKind.FunctionDeclaration) {
          parseTSFunction(receiver, statement);
        }
      }
    } else {
      // console.log(Object.entries(ts.SyntaxKind).find(e => e[1] === node.kind), node);
    }
  });
});

annotationMap.set('global.queueMicrotask', [['callback']]);

const out = [];
for (const [key, value] of annotationMap) {
  if (value.length === 1 && value[0].length === 0) {
    continue; // eslint-disable-line no-continue
  }
  value.sort((a, b) => a.length - b.length);
  out.push(`  [${key}, ${JSON.stringify(value)}]`);
}

fs.writeFileSync('./src/annotation_map.js', `'use strict';

/* eslint-disable */

// Generated by generate_annotations.js
// This file maps native methods to their signatures for completion
// in the repl. if a method isn't listed here, it is either unknown
// to the generator script, or it doesn't take any arguments.

${[...needToRequire].map((n) => `const ${n} = require('${n}');`).join('\n')}

module.exports = new WeakMap([
${out.join(',\n')},
].filter(([key]) => key !== undefined));
`);
